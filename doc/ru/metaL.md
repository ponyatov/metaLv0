# ru/ metaL: [meta]programming [L]anguage

см. также <a href=modules.html>модули документации</a> и
<a href=index.html>главную страницу</a> (README.md)

***

Язык (мета)программирования `metaL` был разработан как смесь Lisp и Python, но с точки зрения не синтаксиса, а духа этих языков.

* *Python* прост в использовании и имеет очень удобный синтаксис
* *Lisp* обладает волшебством самомодификации, способной изменять программу во
  время выполнения, и работать с программой как со структурой данных
* *Smalltalk* это чистый ООП-язык, работающий на основе передачей сообщений,
  которая идеально подходит для распределенных и параллельных систем.

Цель и идеология `metaL` не в написание прикладных программ, а **создание
программ, которые генерируют исходный код других программы** (генерация Си-кода, который может быть скомпилирован и запущен на любой компьютерной системе).

Не пытайтесь написать что-то, что должно быть быстрым, типа числодробилки или
игрового движка -- `metaL` просто так не работает, и быстрое выполнение не предполагалось. Он был создан для манипуляций с программными структурами, и
вы можете писать очень быстрые программы в `metaL`, если вы используете его
правильно: для генерации исходного кода вашего приложения.

***

### Запуск системы

* online-версия: https://repl.it/@metaLmasters/metaL<br>после входа на сайт repl.it дождитесь завершения инициализации песочницы, кликните мышью в командной консоли, и введите команду запуска:
```
Python 3.8.2 (default, Feb 26 2020, 02:56:10)
> make install
> bin/python3 -i metaL.py

<vm:metaL> _
```

* локальная установка на собственный компьютер
```sh
~$ git clone -o gh https://github.com/ponyatov/metaL
~$ cd metaL ; make install
```

* интерактивный режим с автоматическим запуском @ref REPL()
```sh
~/metaL$ make metaL/repl
```

* только в Python-режиме: нажмите [Ctrl]+[C] для выхода в интерактивную
  консоль Python
```sh
~/meta$ bin/python3 -i metaL.py

<vm:metaL> ^C
Traceback (most recent call last):
  File "metaL.py", line 1472, in <module>
    REPL()
  File "metaL.py", line 1454, in REPL
    command = input(vm.head(test=True) + ' ')
KeyboardInterrupt
>>> _
```

* самый правильный способ: Python-only с отдельным рабочим файлом и REPL:<br>
  текст редактируется в файле, по [Shift]+[Enter] выделенные куски или строки отсылаются в интерактивную консоль Python, по [F12] система перезапускется с автосохранением проверенного кода<br>
  комментарии с двойными `##` и `@`-префиксами относятся к разметке [DoxyGen](https://en.wikipedia.org/wiki/Doxygen), которая используется для подготовки этого руководства

```sh
~/metaL$ code hello.py
~/metaL$ make hello/repl
```
```py
# file
# brief Hello World

from metaL import *

MODULE = Module('hello')
print(MODULE)
# <module:hello> #a04475a2 @7f226970f630
```

***

Для работы online достаточно зайти в песочницу на https://repl.it/@metaLmasters/metaL
```
Python 3.8.2 (default, Feb 26 2020, 02:56:10)
> pwd
/home/runner/metaL
```
```
> make install
> bin/python3 -i metaL.py

<vm:metaL> #10e7d970 @7f38abc26070
    ABOUT = <string:homoiconic metaprogramming system\n* powered by `metaL`> #0dfa5b4e @7f38abc26580
    vm = <vm:metaL> #10e7d970 @7f38abc26070 _/

<vm:metaL> _
```


`metaL` на самом деле это **два** языка:
* `metaL`-скрипт со своим синтаксисом, опционален, и находится в зайчаточном
  состоянии (использовать не будем)
    * **используется только однострочный синтаксис** для каждой команды   
    (ограничение функции `input()` в Python)
    * выполняется как строка в Python-режиме через функцию @ref metaL()
    * выполняется интерактивно после запуска @ref REPL()
* `metaL` как он изначально задумывался: no-syntax **язык определённый на
  данных** (в виде *самоинтерпретируемых структур данных* реализованных на
  Python)

`metaL` задумывался как модуль расширения Python, который использует рантайм
CPython3, интерпретатор и синтаксис Python включая REPL, и **объектный граф**
как универсальную структуру для представления одновременно и программ и данных.
Python как язык очень прост в освоении, но крайне ограничен, и неприменим в
чистом виде для некоторых приложений (микроконтроллеры, используемые в
приложениях IoT, системы жёсткого реального времени, компактные приложения и
`unikernel` микроОС для виртуальных сред).

Предполагается, что `metaL`
* может быть реализован как *гостевой язык данных* на любом удобном для
  программиста **хост-языке** (предпочтительны динамические с REPL: Python,
  Lisp/Clojure, PHP), в виде [гомоиконичного](https://ru.wikipedia.org/wiki/%D0%93%D0%BE%D0%BC%D0%BE%D0%B8%D0%BA%D0%BE%D0%BD%D0%B8%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C) *интерпретатора структур данных*
* специальный синтаксис не используется, для работы с `metaL` применяется REPL и
  синтаксис хост-языка, особенно для написания различных **трансформаций** и
  методов, по крайней мере пока `metaL` не станет достаточно зрелым чтобы быть
  переписанным на самом себе
* основной и единственный метод: *гетерогенное генеративное*
  **мета-программирование**
  * на `metaL` **описываются модели** проектируемых приложений,
    программно-аппаратаных систем, *модели предметной области*, методы преобразования моделей
  * полученные прикладные модели транслируются в компилируемые модели (AST,
    атрибутные грамматики) **целевого языка программирования**
  * *компилируемые модели* транслируются в произвольно выбранный 1+ целевой
    язык, с которым работает команда разработчиков
  * полученный исходный код компилируется *backend-компилятором* (gcc, javac,..)
    и интегрируется с любыми существующими системами и инструментами
  * за счёт разделения host-языка разработки и моделирования (используется
    только в design time), и target-языка реализации (compile/runtime),
    избавляемся от блокировок по инструментарию, и необходимости заставлять всю
    команду учить и поддерживать еще один птичий язык
* главная задача `metaL`: **создание неограниченно-расширяемой языковой среды**
  для проектирования и моделирования, в которой разработчик может самостоятельно
  реализовать и применять любые подходы и методы программирования, не
  ограничиваясь возможностями хост-языка, и не имея жёсткой привязки к целевому
  стеку (язык, runtime, библиотеки, фреймворки, ОС, СУБД, схема развёртывания, и
  т.д.).
* для проектов использующих динамические хост-языки, возможно использование
  `metaL` в рантайме в **режиме симуляции**, но такое использование допускается
  только для прототипирования, сбора статистики, оптимизации и отладки. Никаких
  средств контроля типов, управления доступом к памяти и ресурсам в `metaL` не
  планируется, поэтому при взломе приложения работающего в режиме симуляции
  атакующий получает полный неограниченный доступ. В случае ошибок поведение
  системы непредсказуемо, и возможны любые повреждения данных. Целевая
  компиляция моделей добавляет средства контроля кода, доступные для
  backend-компилятора (как минимум проверку типов), и код безопасности
  предусмотренный разработчиком и авторами `metaL`-библиотек.

![](hosttarget.svg)

* *значительное преимущество* применения `metaL` перед обычным ручным
  программированием -- возможность строить гетерогенные распределенные системы,
  состоящие из разнородных компонентов (backend, RDBMS, MQ, frontend,
  хранилища,..), **с обеспечением консистентности логики и данных между разными
  частями системы**. Особенно важно для систем, 
  * реализованных на разных языковых стеках,
  * выполняющих множество разнотипных задач, 
  * при часто меняющихся в процессе эксплуатации требованиях (по велению левой
    пятки, сделать вчера),
  * с большим объёмом legacy (PHP5, Delphi)
  * работа с данными в специализированных desktop приложениях.
  * распределённые системы сбора/обработки данных (телеметрия, мониторинг,
    измерительные сети, АСУ ТП, IIoT,..)

***

![](tutorial.svg)

### REPL: Read-Eval-Print-Loop

*Цикл чтение-вычисление-печать* и интерактивный режим Python, сочетаемый с
посылкой кусков `.py` кода из редактора -- важный способ работы с `metaL`.

Сначала вы отлаживаете код интерактивно, выполняя код пошагово, и наблюдая
результат его выполнения, а затем перезапускаете Python c автосохранением
рабочего файла со всеми сделанными изменениями. В результате у вас есть
одновременно и интерактивность, и резервная копия в системе контроля версий. В
идеале конечно была бы графическая система в стиле Smalltalk с графикой,
персистентной памятью хранящей полное состояние системы при перезапусках, и
интерактивный отладчик, но реализовать такую систему на порядки сложнее, чем
использовать уже готовые встроенные возможности IDE (VSCode).

### Hello World

```sh
~/metaL$ code hello.py
~/metaL$ make hello/repl
```

```py
MODULE = Module('hello')
print(MODULE)
# <module:hello> #a04475a2 @7f28c441a710
```

Модуль -- объект-контейнер, объединяющий другие объекты, относящиеся к одному
`.py`-файлу (модулю), единице компиляции (C++) или даже большому проекту.

Базовый Module не умеет ничего, и работает только как универсальный контейнер.
Наследованные от него классы модулей включают генерацию целевого кода, создание
файлов и каталогов, вплоть до генерации достаточно сложных объектных графов с
моделями типовых проектов Django и полноразмерных бизнес-сервисов.
```py
class djModule(pyModule):
    def __init__(self, V=None):
        pyModule.__init__(self, V)
        reqs = self.diroot['reqs']
        reqs // 'django'
        reqs.sync()

MODULE = djModule('bully')
```
```
~/metaL$ find bully

bully/README.md
bully/Makefile
bully/bully.py
bully/config.py
bully/requirements.txt
bully/.vscode/settings.json
bully/.gitignore
bully/apt.txt
```

### `anyModule`

В качестве примера можно разобрать часть кода @ref anyModule

```py
class anyModule(Module):
    def __init__(self, V):
        # сначала вызываем супер-класс, от которого наследуем свой тип проекта
        Module.__init__(self, V)
        # заполняем метаинформацию модуля
        # часть данных можно наследовать из другого объекта (глобальной виртуальной машины metaL)
        self << vm['AUTHOR']
        self << vm['EMAIL']
        self['year'] = vm['YEAR']
        self << vm['LICENSE']
```
```py
hello = anyModule('hello')
print(hello)
```
Здесь мы видим несколько странных операторов, и еще более странный вывод объектного графа:
```
<anymodule:hello> #3d2f9e06 @7f4def8c2748
        author = <author:Dmitry Ponyatov> #f9ea65c5 @7f4df0005860
                email = <email:dponyatov@gmail.com> #5c493931 @7f4df0005828
        email = <email:dponyatov@gmail.com> #5c493931 @7f4df0005828 _/
        license = <license:MIT> #b2969ad0 @7f4df0005908
        year = <integer:2020> #04567cb9 @7f4df00058d0
```

## `Object`

```py
# базовый класс узла объектного графа
class Object:
    # конструктор создает узел с заданным скалярным значением
    def __init__(self, V):
        # имя символа, узла, скалярное значение (строка, число,..)
        self.val = V
        # слоты = атрибуты = словарь {строка:ограф}
        self.slot = {}
        # упорядоченные вложенные графы = AST = вектор = стек = очередь
        self.nest = []
```
Базовый класс узла свободно наследуется, определяя конкретные типы данных,
исполняемые/компилируемые элементы программ, и компоненты моделей. Часть типов
узлов задана в языке `metaL` как предопределенные, от них вы можете наследовать
свои собственные типы. Возможность множественного наследования зависит от
хост-языка (в Python есть), но для переносимости желательно от него избавится.

![](taxonomy.svg)

### Операторы

Также для базового Object задано несколько операторов, позволяющих адресовать
части графа: слоты по строковым ключам, вложенные элементы по целым числам,
добавлять вложенные подграфы в стек, удалять слоты по имени и т.п.
* `A.keys()`
  <br> список ключей слотов
* `A[key] ~> A.slot[key:str] | A.nest[key:int] `
* `A[key] = B`
  <br> создание/изменение слота по имени `key` (Python-строка)
* `A << B ~> A[B.type] = B`
  <br> присвоение слота с именем типа операнда (по левому полю `<<T:V>`)
* `A >> B ~> A[B.val] = B`
  <br> присвоение слота со значением `.val` операнда (по правому полю `<T:V>>`)
* `A // B -> A.push(B)`
  <br> запихнуть операнд как в стек (последним)
* ...

Для числовых типов также определены арифметические операторы, через
соответствующие методы класса.

Сами операторы также определены как класс `Op`, т.е. вы можете конструировать
арифметические выражения в виде дерева, и после запуска дерева на выполнение
(вычисление), каждый объеет-оператор знает как себя вычислить (рекурсивно).

### Дамп

Наконец, для интерактивной работы с графами и просмотра их состояния необходим
какой-то способ их отображения. Для интерактивной консоли как минимум нужен
текстовый формат. Также можно реализовать графический вывод. Для текстового
формата естественным является отображение в виде дерева: количество табуляций в
каждой строке задает глубину от начального узла, с которого начинается обход
графа.

Для каждого узла выводится заголовок в форме `<T:V>`, в который также входят
* хеш-сумма, вычисляющаяся по данным и хэшам вложенных графов, и
* указатель в памяти (позволяет отличить два объекта с одинаковым значением)

Далее идут слоты в форме `<ключ> = <граф (поддерево)>` и вложенные элементы с
числовым индексом.

Объектные графы являются циклической структурой, т.е. в любом графе в качестве
вложенного элемента может оказаться он сам. Для таких случаев при выводе дампа
ведется список уже выведенных объектов, и их повторения выводятся только
заголовком с суффиксом `_/`:
```
<vm:metaL> #10e7d970 @7f24f91b1278
        module = <class:Module> #e4c6b3b6 @7f24f91b1390
        vm = <vm:metaL> #10e7d970 @7f24f91b1278 _/
```

### `anyModule` продолжение

```py
class anyModule(Module):
    def __init__(self, V):
        ...
        # diroot: корневой каталог проекта
        self.diroot = Dir(V) # создаем как поле Python-объекта
        self << self.diroot  # также регистрируем как поле self.[`dir`]

# <anymodule:hello> #eca3654b @7f05e12e1748
#     dir = <dir:hello> #9338a3f6 @7f05e12e1898
```

Теперь при создании любого экземпляра `anyModule('hello')` или его наследника в
текущем каталоге будет создаваться каталог `~/metaL/hello`.
