<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>metaL/py: ![logo](static/logo.png) `metaL`</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">metaL/py
   </div>
   <div id="projectbrief">Repl.it Programming Language Jam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">![logo](static/logo.png) `metaL` </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>version for Repl.it Language Jam contest</h2>
<p><a href="https://repl.it/@metaLmasters/metaL">https://repl.it/@metaLmasters/metaL</a></p>
<p>Discord: <a href="https://discord.gg/5CYZdt6">https://discord.gg/5CYZdt6</a></p>
<p>tutorial: <a href="https://ponyatov.github.io/metaL/tutorial.html">https://ponyatov.github.io/metaL/tutorial.html</a></p>
<p>doxygen manual: <a href="https://ponyatov.github.io/metaL">https://ponyatov.github.io/metaL</a></p>
<ul>
<li><a href="https://blog.repl.it/langjam">https://blog.repl.it/langjam</a></li>
<li><a href="https://repl.it/talk/share/metaL-for-replit-Language-Jam-contest/46470">https://repl.it/talk/share/metaL-for-replit-Language-Jam-contest/46470</a></li>
</ul>
<p>(c) Dmitry Ponyatov &lt;<a href="#" onclick="location.href='mai'+'lto:'+'dpo'+'ny'+'ato'+'v@'+'gma'+'il'+'.co'+'m'; return false;">dpony<span style="display: none;">.nosp@m.</span>atov<span style="display: none;">.nosp@m.</span>@gmai<span style="display: none;">.nosp@m.</span>l.co<span style="display: none;">.nosp@m.</span>m</a>&gt; 2020 MIT</p>
<p>github: <a href="https://github.com/ponyatov/metaL">https://github.com/ponyatov/metaL</a></p>
<h2>Language Ideas Promo</h2>
<ul>
<li>take Lisp homoiconic nature and port it to CPython3 stack (VM &amp; libs)</li>
<li>provide a light environment for <b>metaprogramming by code generation</b><ul>
<li><code><a class="el" href="namespacemetaL.html">metaL</a></code> is a special language for writing programs that write other programs (in C &amp; Python as <em>target languages</em>)</li>
<li>interactive REPL with pushing generated code into files is a primary method of work</li>
<li>system bootstrap via <a class="el" href="group__circ.html">Metacircular</a> redefinition</li>
</ul>
</li>
<li>protect people from the parens soup by using infix syntax and AST-friendly data structure in place of classic lists</li>
<li>integrate best features from Python, Lisp/Clojure, and <a class="el" href="namespaceSmalltalk.html">Smalltalk</a></li>
<li>targets on IoT programming:<ul>
<li>server-side <a class="el" href="group__dja.html">Dja</a> in Python/Django/PostgreSQL (todo: highly optimized C/C++/Rust? code)</li>
<li>ANSI C code generation is required by design<ul>
<li>uses amazing <a href="https://bellard.org/tcc/">TCC</a> host compiler backend for fast debug</li>
</ul>
</li>
<li>cross-compiling to many embedded devices including AVR8, Cortex-M, and MSP430 microcontrollers<ul>
<li>uses GCC cross-compiler for portability</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><code><a class="el" href="namespacemetaL.html">metaL</a></code> is not a programming language</h2>
<p><code><a class="el" href="namespacemetaL.html">metaL</a></code> <b>is a method of programming</b> in Python (or any other language you prefer: JS, PHP,...)</p>
<p><code><a class="el" href="namespacemetaL.html">metaL</a></code> works over two key features:</p><ul>
<li>homoiconic self-modifying data structures</li>
<li>metaprogramming via code generation</li>
</ul>
<p>That's why DML/DDL syntax parser is not required and is the only an optional feature: parser was left there just to be a demo of the third magic feature of the <code><a class="el" href="namespacemetaL.html">metaL</a></code>:</p><ul>
<li>custom user-defined syntax</li>
</ul>
<p>All <code><a class="el" href="namespacemetaL.html">metaL</a></code> structures can be defined directly in the <em>host language</em> (Python), the syntax parser is only a way to do it more simplified and to work in symbiosis with Python REPL + VSCode. VSCode has the ability to send selected parts of code from a text editor to a terminal with running REPL. This sending has some disadvantage: Python's <code>input()</code> function can input only a single string, so when we send a text from a VSCode, we can't detect was it a single line or multiple lines text block. So, the syntax was chosen single-lined. It also points, that DML/DDL in <code><a class="el" href="namespacemetaL.html">metaL</a></code> is not a programming language, it's a language of CLI commands.</p>
<p>As we can use code generation for producing transformations in a host language, <em>it is possible to leave <code><a class="el" href="namespacemetaL.html">metaL</a></code> without user-defined functions</em> and continuations, which are complex to understand and implement for the newbie language designer. User function (method, new user type class) can be specified, translated into host language without its execution, resulting code should be pasted into <code><a class="el" href="metaL_8py.html" title="powered by metaL ">metaL.py</a></code>, and finally system restarts with this new working transformation. As <code><a class="el" href="namespacemetaL.html">metaL</a></code> were primarily designed for work with interactive code generation, such system redefinition method is suitable for use, especially if we'll have <code><a class="el" href="namespacemetaL.html">metaL</a></code> <a href="https://stackoverflow.com/questions/1481053/what-is-the-exact-definition-of-a-metacircular-interpreter">metacircular implementation</a> in the system release.</p>
<h3>Generic Code Templating</h3>
<p>The idea of <code><a class="el" href="namespacemetaL.html">metaL</a></code> originates from an idea of the <em>generic code templating</em>: any mainstream programming language we're using any day at work or for a hobby is limited by its vendors, the huge community which uses it, and a language stack of tools and libraries. Even if you have enough skills to take something like CPython implementation and hack it to add some language modifications you want, you never can use it in production &ndash; these mods make the language incompatible with the generic branch, and the most important it makes your team developers incompatible with the rest of community. If you try to use your own hacked Python or some homebrewed language for work, you will be kicked by your employer and team as it introduces risk in hiring new developers, adds vendor lock on uncommon language and tools, and dissipates efforts also on custom language support.</p>
<p>The idea about code templating is a way of taking the power of custom highest-level language still having no incompatibles with your production team. In most cases, nobody locks you on the IDE you use for development, so if you also add some shadow tool that generates human-readable code in the mainstream language of your team, you'll have a chance to take the power without risks shown above.</p>
<p>The problem is how can we make some language especially designed to be such a magic wand. First of all, it must be very flexible and dynamic, and at the same time it must not be effective and fast in terms of computation, it should be just fast enough and not more. Next, it is required that this language must have the highest extensibility to let you describe and implement any method or approach of programming you desire. Lisp language dialects are well known at this position, but they have scary syntax and at the same time are well-known as esoteric. So, to make such a magic language, we can take the Lisp dynamic nature, implement its runtime in any language you prefer (Python), cover it with infix syntax parser which can be extended by a user as he wants, and finally focus on making jigs and features suitable for describing software systems at the highest level and simplifying of code generation.</p>
<p>The reverse path is the legacy code analysis from source code to high-level models. There is a common problem of moving some old software systems to a new language stack with fixing a lot of architecture bugs. I can't remember any freeware tool or system which able to provide an environment for sucking in source code in arbitrary (ancient) languages, which can provide a handy way for reverse engineering, making software models, detecting used algorithms and methods, and regenerating software from these refurbished models.</p>
<h3>Concept Programming</h3>
<p>CP here is a programming model described in the works of Enn Heraldovich Tyugu about model-based software development. It is not mean the term by Alexsandr Stepanov here. The common idea is about making domain models describe the problem in a wide in the form of relation networks, and automatic program (code) synthesis from specifications to solve concrete tasks. This synthesis works over these networks using them as <em>generic knowledge representation</em>.</p>
<ul>
<li><a href="http://www.cs.ioc.ee/~tyugu/">http://www.cs.ioc.ee/~tyugu/</a></li>
<li>J. Symbolic Computation (1988) 5, 359-375\ The Programming System PRIZ [sym88]</li>
</ul>
<h2>Base Node Class</h2>
<p>The core of the <b>graph interpreter system</b> is a homoiconic model uses a directed graph of objects as both program and data representation. The idea was taken from [minsky] and extended with the ability to store not only slots (attributes) but also hold any knowledge frames in an ordered container.</p>
<p><a href="https://www.youtube.com/watch?v=nXJ_2uGWM-M">https://www.youtube.com/watch?v=nXJ_2uGWM-M</a></p>
<p>Frames originated as a technology used for knowledge representation in artificial intelligence. They are very close to objects and class hierarchies in object-oriented languages although their fundamental design goals are different. Frames are focused on the explicit and intuitive representation of knowledge whereas objects focus on encapsulation and binding data with processing procedures. Original Marvin Minsky's concept <em>lacks some principal features for software design</em>, so it must be extended with the ability to <em>store sequential collections</em>.</p>
<p>In practice, the techniques and capabilities of the frame model and object-oriented languages overlap significantly so much as we can treat frames not only a native superset of OOP but they drastically extend object design concepts wider: we can represent any knowledge in frames, and use any programming paradigms as we desire.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Frame:</div><div class="line">    <span class="keyword">def </span>__init__(self, V):</div><div class="line">        <span class="comment"># scalar data value</span></div><div class="line">        <span class="comment"># mostly names the frame, but also can store things like numbers and strings</span></div><div class="line">        self.val = V</div><div class="line">        <span class="comment"># named slots = attributes = string-keyed associative array</span></div><div class="line">        self.slot = {}</div><div class="line">        <span class="comment"># ordered storage = program AST nested elemens = vector = stack</span></div><div class="line">        self.nest = []</div><div class="line">        <span class="comment"># unique storage id (Redis,RDBMS,..)</span></div><div class="line">        self.sid = <span class="stringliteral">&#39;@%x&#39;</span> % id(self)</div></div><!-- fragment --><p>This data node structure which combines named slots with the ordered collection is definitively required for representing any program source code, as this is very close to classical AST and attribute grammar but uses graph in place of the attributed tree. The object graph (frame) representation of a program as a primary form is effective and <em>native for any work involved with source code transformations</em>: synthesis, modifications, analysis, cross-language translation, etc.</p>
<p>Factically, <b>we don't require any text programming language at all</b>, as this <em>Executable Data Structure</em> can</p>
<ul>
<li>hold any program statically (as storage),</li>
<li>be executed by the EDS-interpreter, so it is <em>active</em> data</li>
<li>can be translated into any mainstream programming language or</li>
<li>[cross-]compiled into machine code via LLVM.</li>
</ul>
<h3>Homoiconic programming model</h3>
<p><b>Homoiconicity</b> is a property of a programming language in which any program is <em>simultaneously</em></p>
<ul>
<li>an easy to modify <em>data structure</em>, and</li>
<li>an <em>executable program representation</em> (program source code).</li>
</ul>
<p>In a homoiconic language, a programmer does not just have access to the source code, but the language itself specifically provides tools and easy to use methods for convenient work with parts of programs (represented as generic data) in runtime.</p>
<ul>
<li>Say, if you include source code of your program in C++ into the distribution package, you can work with the program code as data, but only at the level of text files, or using third-party analysis libraries. In the C++ language itself, there are no dedicated tools for reading, modifying, or generating source code.</li>
<li>Conversely, in the Lisp language, all programs are represented in the form of executable lists &ndash; these lists are simultaneously a program and the usual universal data structure for working with which the language was specially created.</li>
</ul>
<h3>EDS Interpreter</h3>
<p>In order to use the advantages of homoiconicity in your programs written in any conventional languages (C++, Java,..), you need to integrate an <b>EDS-interpreter</b> into your programs that will</p>
<ul>
<li><em>execute some data structure as a program</em>, and additionally</li>
<li>provides high-level tools for modifying program/data graph in runtime.</li>
</ul>
<p>It is not necessary that this interpreter should include a parser of some scripting language, as <em>graph structure can be generated directly by code in the implementation language</em>, and by structure self-transformation. To create a program in such a system, you only need to have any way to create an <em>executable data structure</em> in memory: it can be GUI-based drawing, text format parser, external graph database, or some C++ code that forces the compiler to include such a structure in the executable file statically.</p>
<h3><code><a class="el" href="namespacemetaL.html">metaL</a></code> is no-syntax language</h3>
<p>In a long long time, CLI (command-line interface) and scripting show itself very effective from the first days of computing and don't go to become obsolete. So, it is handy to have some lite DDL/DML script language in front of your metaL-based system just to be able to use it for initialization files, and making some interactive queries to the running system. <em>This DDL/DML is not the <code><a class="el" href="namespacemetaL.html">metaL</a></code> itself</em>, its just a way to host system snapshot in git-friendly text files and provide very light CLI. But, <code><a class="el" href="namespacemetaL.html">metaL</a></code> is the language of live data structures in running computer memory. It specifies common ides</p><ul>
<li>how these structures are presented (unified storage),</li>
<li>methods of computation (some sort of expression evaluation, close to AST interpretation), and</li>
<li>set of node types described in the language core, which you can expand next as you want.</li>
</ul>
<h3>Metaprogramming</h3>
<p>Metaprogramming &ndash; when one program modifies (generates) another program, including itself.</p>
<p>Metaprogramming is a method of boosting your efficiency as a programmer by expanding the language you use. If you write very similar code every day, in languages ​​that can do meta (Lisp, Nim), you can write small macro programs that will run during the compilation stage, and generate new code by a template, or modify an existing code the way as you need it. Factically, you can add to the language those features that are needed for a narrow set of your specific tasks.</p>
<p>In order to be able to use metaprogramming in a full scale, the language or programming system you are using must be homoiconic. If you want to use this method with industrial programming languages, the use of an EDS interpreter will allow you to quickly and conveniently solve your problems, paying for it with some losses in the speed of programs and memory usage (see a comparison of interpreters vs the compilers into machine code).</p>
<h2>Links</h2>
<p>[SICP] <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book-Z-H-4.html#%_toc_start"><b>Structure and Interpretation of Computer Programs</b></a> Harold Abelson, Gerald Jay Sussman, Julie Sussman // MIT Press, 1996, ISBN 0-262-51087-1</p>
<p>[iSICP] <a href="https://xuanji.appspot.com/isicp">interactive SICP</a></p>
<p>[plai] Shriram Krishnamurthi <a href="https://www.plai.org">Programming Languages: Application and Interpretation</a></p>
<p>[papl] Joe Politz, Ben Lerner <a href="https://papl.cs.brown.edu/2020/">Programming and Programming Languages</a></p>
<p>[minsky] Marvin Minsky <a href="https://web.media.mit.edu/~minsky/papers/Frames/frames.html"><b>A Framework for Representing Knowledge</b></a> // MIT-AI Laboratory Memo 306, June, 1974. Reprinted in The Psychology of Computer Vision, P. Winston (Ed.), McGraw-Hill, 1975.</p>
<p>[tyugu] <b>Knowledge-Based Programming</b> Enn Tyugu 1988 // Addison-Wesley Longman Publishing Co., Inc.</p>
<p>[tyuguru] Э.Х.Тыугу <b>Концептуальное программирование</b>. М.: Наука, 1984. 255 с</p>
<p>[sym88] J. Symbolic Computation (1988) 5, 359-375\ <a href="https://www.academia.edu/18315153/The_programming_system_PRIZ?auto=download"><b>The Programming System PRIZ</b></a> \ G.Mints, E.Tyugu, Institute of Cybernetics, Estonian Academy of Sciences,Tallinn 200108, USSR</p>
<p>[priz] <b>Инструментальная система программирования ЕС ЭВМ (ПРИЗ)</b> / М.И. Кахро, А.П. Калья, Энн Харальдович Тыугу . – Изд. 2-е – Москва : Финансы и статистика, 1988 . – 181 с ISBN 5-279-00111-2</p>
<p>[actor] Hewitt, Meijer and Szyperski <a href="https://www.youtube.com/watch?v=7erJ1DV_Tlo">The Actor Model (everything you wanted to know...)</a></p>
<h3>UnisonWeb</h3>
<p><code><a class="el" href="namespacemetaL.html">metaL</a></code> grabs a great idea about immutable, homoiconic, and distributed data structures from the <code>Unison</code> language. It is also important to note the method of building the distributed knowledge database using incremental computation of data elements.</p>
<ul>
<li><b>The Unison language</b> <a href="https://www.unisonweb.org">https://www.unisonweb.org</a><ul>
<li>Paul Chiusano <a href="https://www.youtube.com/watch?v=gCWtkvDQ2ZI">Unison: a new distributed programming language</a> Strange Loop '19</li>
<li><a href="https://www.youtube.com/watch?v=yicXcdLI2YA">Unison: An Introduction and Q&amp;A with Rúnar Bjarnason</a></li>
</ul>
</li>
</ul>
<h3>Literate Programming</h3>
<p>Literate Programming concept targets on mixing code with documentation, but shows the original method is not alive due to limits forced by sequential code. Most programming languages are sequential by its nature, so original <code>cweb</code> forces you to write manual in order of your code, starting from <code>include</code> etc. Disjoining code from documentation elements allows doing arbitrary structure of the manual, and include parts of code as interactive elements.</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Literate_programming">https://en.wikipedia.org/wiki/Literate_programming</a></li>
<li><a href="https://roamresearch.com">Roam Athens Research</a><ul>
<li><a href="https://www.notion.so/MVP-Update-Funding-and-Why-I-Started-Athens-e68822f0c3654660ae621cdcbf932bc4">https://www.notion.so/MVP-Update-Funding-and-Why-I-Started-Athens-e68822f0c3654660ae621cdcbf932bc4</a><ul>
<li><a href="https://github.com/athensresearch/athens">https://github.com/athensresearch/athens</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><a class="el" href="namespaceSmalltalk.html">Smalltalk</a> language and pure OOP</h3>
<p><code><a class="el" href="namespacemetaL.html">metaL</a></code> does not follow the <a class="el" href="namespaceSmalltalk.html">Smalltalk</a> language semantics, and especially its strange syntax, but it looks very closely on its message-passing computation model, especially in terms of async messaging in the [actor] model. To understand the nature and the power of <a class="el" href="namespaceSmalltalk.html">Smalltalk</a> without the need of installing or learning it you can see two next intro videos; don't skip a few firsts in [lawson] playlist where you can see the magic of <a class="el" href="namespaceSmalltalk.html">Smalltalk</a>'s interactive debugging and persistent memory.</p>
<p>[lawson] <a href="https://www.youtube.com/playlist?list=PL6601A198DF14788D">https://www.youtube.com/playlist?list=PL6601A198DF14788D</a></p>
<p>[kay15] Alan Kay, 2015: <a href="https://www.youtube.com/watch?v=NdSD07U5uBs">Power of Simplicity</a></p>
<p><a href="http://stephane.ducasse.free.fr/FreeBooks/">http://stephane.ducasse.free.fr/FreeBooks/</a></p>
<p>[blue] Adele Goldberg, David Robson <a href="http://stephane.ducasse.free.fr/FreeBooks/BlueBook/Bluebook.pdf">Smalltalk-80: The Language and its Implementation</a> XeroxParc lab, Addison-Wesley, 1983</p>
<p>[little] Tim Budd <a href="http://stephane.ducasse.free.fr/FreeBooks/LittleSmalltalk/ALittleSmalltalk.pdf">A Little Smalltalk</a> Addison-Wesley 1987</p>
<h3>Misc</h3>
<p>[dbms] <b>Database Systems. The Complete Book</b> 2nd ed. Hector Garcia-Molina, Jeffrey D. Ullman, Jennifer Widom</p>
<p>[hickey] <a href="https://www.youtube.com/watch?v=eWbPLSJZ5Zw">https://www.youtube.com/watch?v=eWbPLSJZ5Zw</a></p>
<p>[mdmp] Vytautas à tuikys, Robertas Damaševičius <b>Meta-Programming and Model-Driven Meta-Program Development: Principles, Processes and Techniques</b> Springer London, 2013, ISBN 978-1-4471-4126-6 </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
