<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>metaL/py: How hard is it to develop your own programming language? Is it worth it?</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">metaL/py
   </div>
   <div id="projectbrief">Repl.it Programming Language Jam</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How hard is it to develop your own programming language? Is it worth it? </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ul>
<li>LinkedIn: <a href="https://www.linkedin.com/posts/dmitry-ponyatov-060646a4_metal-python-programminglanguage-activity-6705018983097090048-9rqm">https://www.linkedin.com/posts/dmitry-ponyatov-060646a4_metal-python-programminglanguage-activity-6705018983097090048-9rqm</a></li>
<li>Answering on: <a href="https://qr.ae/pN2BWT">https://qr.ae/pN2BWT</a></li>
</ul>
<p>It is not hard but needs a huge of work to make it practical.</p>
<p>First, forget about the syntax &ndash; it is a mostly solved problem, almost any language has 1+ library for making syntax parsers. If you like Python, the <a href="https://www.dabeaz.com/ply/">PLY library</a> gives you a full set of syntax support. Furthermore, <b>you can drop out syntax parser totally</b>, by using your host (implementation) language for building AST trees or any other interpretable data structures.</p>
<p>Next, avoid building the classical compiler, it is boring and very limited language pattern. Look closely on the C++, it was originally the pure compiler, but last decade it has become an ill-headed interpreter works on templating/type engine. Yes, it runs some sort of code in compile-time, but the "language" of his metaprogramming code with its semantics and syntax will burn your brain, and you have no tools do debug it.</p>
<p>Don't forget: <b>any programming language interpreter can compile</b> into the fastest machine code, or any other language you want to use (assembly, LLVM, C/C++, Java,..., anything you want including build scripts and SQL): write text files, and compile them with any backend compiler.</p>
<div class="image">
<object type="image/svg+xml" data="quora.svg">quora.svg</object>
</div>
<p><a href="https://qph.fs.quoracdn.net/main-qimg-5c808ff9efeceaaf36594459a0433edb">https://qph.fs.quoracdn.net/main-qimg-5c808ff9efeceaaf36594459a0433edb</a></p>
<ul>
<li>Write your own interpreter,.. NO! Just use any host (implementation) language you like to use, preferred dynamic, like Python JavaScript Clojure Haskell ...</li>
<li>Find some data structure that can represent programs &ndash; I prefer <a href="https://en.wikipedia.org/wiki/Object_graph">object graphs</a>, they can natively represent anything from target language AST/attribute grammar to any models from the application domain and software architect concepts.</li>
<li>Write a set of <code>.compile_to_*()</code> methods for this data structure, which are able to compile every object graph node type into target code you want to use (LLVM, assembly, C, Python code for Django stack + JavaScript,..) &ndash; now you can compile your data structure into the target language. Note here, <b>your models are able to compile itself</b>, by <em>generating code</em>.</li>
<li>Now, you already can compile code, using your/host language interpreter (I use generic Python) as a compiler. <em>Factically, you already wrote your language without writing it</em>. You can build software systems by describing its structure, can build models, can create target language AST tree in host language element by element, and then run <code>AST.compile()</code> method and get C++ code for backend compiling. At this point, you already have your own <b>working language</b> version, even without syntax parser (host language does it for you off the shelf).</li>
<li>Next, use your language for writing applications. Doing this, you are testing your language on real problems, and extend it every time you want. It is the most annoying stage or your language evolution. The most nuisance is writing a lot of code in the host language. It has syntax you are not adopted as ideal, but you must do it because it has a working debugger (the must-have tool, nothing works without it) and because your "language" (as a concept defined over the data structure semantics) not yet defined at these use cases.</li>
<li>While your (meta)language evolves, you find yourself making some sort of code patterns, some concepts repeat again and again. That is <b>the advantage of this complex method &ndash; you can unlimitedly and freely expand your language semantics</b>, especially if your host language has rich inheritance capabilities (like Python with its multiple inheritance, operators override, and dynamics).</li>
<li>Finally, the most magic stage arrived. Your data structures that represent your code and data simultaneously (<a href="https://en.wikipedia.org/wiki/Homoiconicity">homoiconic</a>!) are active <b>executable data structures</b>, which runs by self-interpretation. You can apply one object graph to another graph even itself, and you have got code/data <em>transformations</em> and program <em>self-modification</em> in hands.</li>
<li>It is time to dive into classical computer science: <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">SICP</a>, <a href="https://www.plai.org/">PLAI</a> and <a href="https://papl.cs.brown.edu/2020/">PAPL</a>, algorithms, software design templates, and <a href="https://www.cis.upenn.edu/~bcpierce/tapl/">TAPL</a>. Don't fix on strange programming languages these books use. <em>Concentrate not on syntax, but on ideas and semantics</em> of that code blocks. If you can understand it, then you can reimplement it yourself and use it in real work. Some concepts described in these books are very powerful in programming but unfortunately not available if your favorite mainstream languages, such as pattern matching or logic unification. However, it is not now a problem &ndash; you already implemented the level of <b>language abstraction</b>, because you write code with looks for others like complex code in Python, but factically you are writing in your own language. So, you just can steal that magic into your universe.</li>
</ul>
<h2>So, let's overall.</h2>
<h3>Disadvantage: the complexity of the method.</h3>
<p>Yes, a huge one, but only in later stages. At first stages, you just copy-paste some parts of target languages as strings (most software projects use multiple languages: code, build/deployment/maintenance scripts, JS/HTML, SQL,..), sometimes with replacing tiny elements in these string in Python code, and write them into outer text files. It looks easy even for the newbie: only string interpolation and text file writing.</p>
<p>The next stage of evolving you as a programmer is the data structures kneading. Also looks like a generic skill of any programmer: manipulation with a graph of objects, which references each other, sometimes cyclically. It is not scary, it used almost in any practical software system everywhere. You even have an advantage here: <em>object graph is a unified data structure</em>, any object node is an instance inherited from the base Object class, and you can works with them via unified interfaces. Every inherited class has its own behavior, but all of them share the same single concept: attributed grammar tree (graph). Every object is a data container (even Primitive ones), every node can have arbitrary attributes bound to other object graphs, and every node can have ordered subgraphs:</p>
<div class="fragment"><div class="line"><span class="comment"># base object graph node </span></div><div class="line"><span class="keyword">class </span>Object: </div><div class="line">    <span class="comment"># construct object </span></div><div class="line">    <span class="comment"># param[in] V given scalar value </span></div><div class="line">    <span class="keyword">def </span>__init__(self, V): </div><div class="line">            <span class="keywordflow">if</span> isinstance(V, Object): V = V.val </div><div class="line">        <span class="comment"># symbol name / scalar value (string, number,..) </span></div><div class="line">            self.val = V </div><div class="line">        <span class="comment"># slots = attributes = dict = env </span></div><div class="line">            self.slot = {} </div><div class="line">        <span class="comment"># nested AST = vector = stack = queue </span></div><div class="line">            self.nest = [] </div><div class="line">        <span class="comment"># global storage id </span></div><div class="line">            self.gid = self.sync().gid </div></div><!-- fragment --><p>Next, you define new node classes, which you are need of. And, for every class, you must define methods of code generation, and operator-like methods, when you combine two objects in some manner. Python has operators override, some other languages do it too: you can define custom operators for building data structures like pushing one object into another, and get/set slots (attributes). You can <a href="https://repl.it%2F@repl.it/@metaLmasters/metaL#metaL.py">look here</a> as I do it.</p>
<p>The complexity rises, but in a smooth curve. You can stay on this step as long as you want or forever. If you are satisfied with the level of the <b>generic code templating</b> you have now, it is enough. You also can wrap it with syntax sugar using a <a href="https://www.dabeaz.com/ply/">custom syntax parser generator</a>, fix your language semantics, and focus only on application programming. Maybe you should read a bit <a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html">SICP</a> as en evening reading, just to have an idea what features you are not using.</p>
<h3>Advantages on the other side:</h3>
<ul>
<li><b>generic code templating</b>: you don't need to write almost the same code again and again</li>
<li><b>concept abstraction</b>: you can describe elements of software design in short terms, but generate a large target code which implements it write fastest</li>
<li><b>low-level code in the highest-level scripting language</b>: Python-written code can be as fast as C and assembly in case you <em>know how to use it right</em></li>
<li><b>freedom of programming thinking</b>: you can use any methods in programming but not depend on the software/language stack which your team use and employer require &ndash; they'll get the code in the language they want </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
